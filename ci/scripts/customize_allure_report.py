#!/usr/bin/env python3
"""Allure Report Customization Script.

This script customizes the Allure report generated by Allure commandline.
Following CI/CD best practices for report generation and customization.

Features:
1. Date format standardization (DD-MM-YYYY)
2. Branch information inclusion
3. Clean HTML/CSS modifications
4. No JavaScript redirects or manipulations
5. Performance optimization

Usage:
    python customize_allure_report.py [path_to_report_dir] [options]
    
Options:
    --dummy              Create a dummy report if no results available
    --branch BRANCH      Specify branch name (overrides auto-detection)
    --dry-run            Test run without making changes

Environment Variables:
    ALLURE_REPORT_DIR    Report directory (default: reports/allure-report)
    ALLURE_CREATE_DUMMY  Create dummy report if true (default: false)
    ALLURE_BRANCH        Branch name to use
"""

import os
import sys
import re
import glob
import json
import time
import logging
import subprocess
from datetime import datetime
from pathlib import Path

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger('allure-customizer')

# Version for reproducibility in CI/CD logs
__version__ = "1.0.0"

# Make script idempotent (safe to run multiple times)
DRY_RUN = False


def get_current_date_formatted() -> str:
    """Get current date in DD-MM-YYYY format.
    
    Returns:
        str: Current date formatted as DD-MM-YYYY.
    """
    return datetime.now().strftime("%d-%m-%Y")


def create_nojekyll_file(report_dir: str) -> None:
    """Create .nojekyll file to prevent GitHub Pages from using Jekyll.
    
    Args:
        report_dir: Path to the Allure report directory.
    """
    with open(os.path.join(report_dir, ".nojekyll"), "w") as f:
        pass
    
    logger.info("Created .nojekyll file")


def get_branch_name() -> str:
    """Get the current branch name from environment or git command.
    
    Returns:
        str: Current branch name or a sensible default if not available.
    """
    # Try multiple approaches to get the branch name
    branch = None
    
    # 1. GitHub Actions environment variables
    branch = os.environ.get('GITHUB_HEAD_REF', '')  # For pull requests
    if not branch:
        ref = os.environ.get('GITHUB_REF', '')      # For direct pushes
        if ref.startswith('refs/heads/'):
            branch = ref.replace('refs/heads/', '')
    
    # 2. Try git command
    if not branch:
        try:
            # Try to get from git command as fallback
            branch = subprocess.check_output(['git', 'rev-parse', '--abbrev-ref', 'HEAD'], 
                                          stderr=subprocess.DEVNULL).decode('utf-8').strip()
        except (subprocess.SubprocessError, FileNotFoundError):
            pass
    
    # 3. Look for .git/HEAD file
    if not branch:
        try:
            git_head_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), '..', '..', '.git', 'HEAD')
            if os.path.exists(git_head_path):
                with open(git_head_path, 'r') as f:
                    content = f.read().strip()
                    if content.startswith('ref: refs/heads/'):
                        branch = content.replace('ref: refs/heads/', '')
        except Exception:
            pass
    
    # 4. Try CI environment variables from other systems
    if not branch:
        # GitLab
        branch = os.environ.get('CI_COMMIT_REF_NAME', '')
        # Jenkins
        if not branch:
            branch = os.environ.get('GIT_BRANCH', '')
            if branch and branch.startswith('origin/'):
                branch = branch.replace('origin/', '')
        # Travis CI
        if not branch:
            branch = os.environ.get('TRAVIS_BRANCH', '')
        # CircleCI
        if not branch:
            branch = os.environ.get('CIRCLE_BRANCH', '')
    
    # Final fallback to standard default branch names if still not found
    if not branch or branch == 'unknown':
        if os.path.exists('.git/refs/heads/main'):
            branch = 'main'
        elif os.path.exists('.git/refs/heads/master'):
            branch = 'master'
        else:
            branch = 'main'  # Default to main as a sensible default
    
    return branch


def add_branch_info(report_dir: str, custom_branch: str = None) -> None:
    """Add git branch information to environment properties and make it visible in the UI.
    
    Args:
        report_dir: Path to the Allure report directory.
        custom_branch: Optional custom branch name to use (overrides auto-detection).
    """
    env_file = os.path.join(report_dir, "environment.properties")
    
    # Get branch name - use custom branch if provided, otherwise auto-detect
    branch = custom_branch if custom_branch else get_branch_name()
    logger.info(f"Using branch name: {branch}")
    
    # Read existing environment properties
    if os.path.exists(env_file):
        with open(env_file, 'r', encoding='utf-8') as f:
            lines = f.readlines()
    else:
        lines = []
    
    # Remove any existing Branch property
    lines = [line for line in lines if not line.startswith('Branch=')]
    
    # Add branch at the beginning of the file
    lines.insert(0, f'Branch={branch}\n')
    
    # Write updated environment properties
    with open(env_file, 'w', encoding='utf-8') as f:
        f.writelines(lines)
    logger.info(f"Updated environment.properties with branch={branch}")
    
    # Also try to update the environment.json file which is used by the Allure SPA
    env_json_file = os.path.join(report_dir, "widgets", "environment.json")
    if os.path.exists(env_json_file):
        try:
            with open(env_json_file, 'r', encoding='utf-8') as f:
                env_data = json.load(f)
            
            # For the Allure report in the screenshot, the structure is a list of objects with name/values
            if isinstance(env_data, list):
                # Find if Branch already exists
                branch_found = False
                for item in env_data:
                    if isinstance(item, dict) and item.get("name") == "Branch":
                        item["values"] = [branch]
                        branch_found = True
                        logger.info(f"Updated existing Branch entry in environment.json")
                        break
                
                # If not found, add it at the beginning
                if not branch_found:
                    env_data.insert(0, {
                        "name": "Branch",
                        "values": [branch]
                    })
                    logger.info(f"Added new Branch entry to environment.json")
                
                # Write back the updated data
                with open(env_json_file, 'w', encoding='utf-8') as f:
                    json.dump(env_data, f, indent=2)
                logger.info(f"Saved updated environment.json")
            else:
                logger.warning(f"environment.json has unexpected non-list structure")
        except Exception as e:
            logger.warning(f"Error updating environment.json: {e}")
    else:
        logger.warning(f"environment.json not found at {env_json_file}")
    
    # Direct approach: modify the HTML directly
    html_files = glob.glob(os.path.join(report_dir, "**", "*.html"), recursive=True)
    env_table_modified = False
    
    for html_file in html_files:
        try:
            with open(html_file, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Try direct string replacement for the branch row
            unknown_branch_pattern = r'<tr>\s*<td>\s*Branch\s*</td>\s*<td>unknown</td>\s*</tr>'
            if re.search(unknown_branch_pattern, content):
                new_content = re.sub(
                    unknown_branch_pattern,
                    f'<tr><td>Branch</td><td>{branch}</td></tr>',
                    content
                )
                
                if new_content != content:
                    with open(html_file, 'w', encoding='utf-8') as f:
                        f.write(new_content)
                    env_table_modified = True
                    logger.info(f"Updated branch value in {html_file}")
        except Exception as e:
            logger.warning(f"Error modifying branch in HTML: {e}")
    
    # Create a more aggressive script for the index.html that will dynamically fix SPA content
    index_html = os.path.join(report_dir, "index.html")
    if os.path.exists(index_html):
        try:
            with open(index_html, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Add an immediate script block to update the branch
            branch_script = f"""
<script>
// Immediate script to update branch name
(function() {{
    // Store the actual branch value
    const branchValue = '{branch}';
    
    function setBranchName() {{
        console.log('Running branch name update');
        
        // Try to directly find and update branch in the DOM
        // 1. Check static tables first
        const envTables = document.querySelectorAll('table');
        let branchUpdated = false;
        
        envTables.forEach(table => {{
            // Find all rows with 'Branch' label
            const rows = Array.from(table.querySelectorAll('tr')).filter(row => {{
                const cells = row.querySelectorAll('td');
                return cells.length >= 2 && cells[0].textContent.trim() === 'Branch';
            }});
            
            // For each Branch row:
            rows.forEach(row => {{
                const cells = row.querySelectorAll('td');
                // Update value and move to top if needed
                if (cells[1].textContent.trim() === 'unknown' || cells[1].textContent.trim() !== branchValue) {{
                    cells[1].textContent = branchValue;
                    branchUpdated = true;
                    
                    // Try to move to top of table
                    const firstRow = table.querySelector('tr');
                    if (firstRow && firstRow !== row) {{
                        table.insertBefore(row, firstRow);
                    }}
                }}
            }});
            
            // If no Branch row exists, create one at the top
            if (rows.length === 0 && table.querySelectorAll('tr').length > 0) {{
                const firstRow = table.querySelector('tr');
                const newRow = document.createElement('tr');
                newRow.innerHTML = '<td>Branch</td><td>' + branchValue + '</td>';
                table.insertBefore(newRow, firstRow);
                branchUpdated = true;
            }}
        }});
        
        if (branchUpdated) {{
            console.log('Updated branch name to: ' + branchValue);
        }}
        
        // 2. Also try to update any JSON/API data in the app
        // This is a more aggressive approach that works with SPAs
        try {{
            // If there's any app data/state in global variables
            if (window.allureData || window.allure || window.app) {{
                const appData = window.allureData || window.allure || window.app;
                
                // Look for environment data in common locations
                const findAndUpdateEnv = (obj) => {{
                    if (!obj) return;
                    
                    if (Array.isArray(obj)) {{
                        // Traverse array
                        obj.forEach(item => findAndUpdateEnv(item));
                    }} else if (typeof obj === 'object') {{
                        // Check if this is environment data
                        if (obj.name === 'Branch') {{
                            obj.values = [branchValue];
                        }}
                        
                        // Also check for environment list
                        if (obj.environment && Array.isArray(obj.environment)) {{
                            let branchFound = false;
                            for (const envItem of obj.environment) {{
                                if (envItem.name === 'Branch') {{
                                    envItem.values = [branchValue];
                                    branchFound = true;
                                }}
                            }}
                            
                            if (!branchFound) {{
                                obj.environment.unshift({{
                                    name: 'Branch',
                                    values: [branchValue]
                                }});
                            }}
                        }}
                        
                        // Recursively check all properties
                        Object.values(obj).forEach(val => findAndUpdateEnv(val));
                    }}
                }};
                
                findAndUpdateEnv(appData);
                console.log('Attempted to update branch in app data');
            }}
        }} catch (e) {{
            console.log('Error updating app data:', e);
        }}
    }}
    
    // Run immediately 
    setTimeout(setBranchName, 0);
    
    // Also run after DOM content loaded
    document.addEventListener('DOMContentLoaded', function() {{
        setBranchName();
        // Run several times to catch async renders
        setTimeout(setBranchName, 500);
        setTimeout(setBranchName, 1500);
        setTimeout(setBranchName, 3000);
    }});
    
    // Also observe DOM changes for SPA navigation
    const observer = new MutationObserver(function(mutations) {{
        setBranchName();
    }});
    
    // Start observing once DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {{
        observer.observe(document.body, {{
            childList: true,
            subtree: true
        }});
    }});
}})();
</script>
"""
            # Insert right after the <head> tag
            if '<head>' in content:
                new_content = content.replace('<head>', f'<head>\n{branch_script}')
                with open(index_html, 'w', encoding='utf-8') as f:
                    f.write(new_content)
                logger.info(f"Added immediate branch update script to {index_html}")
        except Exception as e:
            logger.warning(f"Error adding branch script to index.html: {e}")
    
    logger.info(f"Added branch information: {branch}")


def fix_html_title_tags(report_dir: str) -> None:
    """Fix date format in HTML title tags.
    
    Args:
        report_dir: Path to the Allure report directory.
    """
    today = get_current_date_formatted()
    
    # Get branch name for the script
    branch = get_branch_name()
    
    html_files = glob.glob(os.path.join(report_dir, "**", "*.html"), recursive=True)
    for html_file in html_files:
        try:
            with open(html_file, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Fix HTML title tag
            new_content = re.sub(
                r'<title>(?:Allure Report|ALLURE REPORT)(?:\s+\d{1,2}[-/]\d{1,2}[-/]\d{4})?</title>', 
                f'<title>ALLURE REPORT {today}</title>', 
                content
            )
            
            # Fix visible title in the HTML content - more specific pattern matching
            # Match both MM/DD/YYYY and DD-MM-YYYY formats
            date_patterns = [
                # Match "ALLURE REPORT MM/DD/YYYY" format seen in screenshot
                r'(ALLURE\s+REPORT\s+)(\d{1,2})/(\d{1,2})/(\d{4})',
                # Also match other possible formats
                r'(ALLURE\s+REPORT\s+)(\d{1,2})-(\d{1,2})-(\d{4})',
                r'(Allure\s+Report\s+)(\d{1,2})/(\d{1,2})/(\d{4})',
                r'(Allure\s+Report\s+)(\d{1,2})-(\d{1,2})-(\d{4})'
            ]
            
            for pattern in date_patterns:
                # Replace with the correct DD-MM-YYYY format
                # Group 2 is the month, 3 is the day, 4 is the year in the regex
                new_content = re.sub(
                    pattern,
                    lambda m: f"{m.group(1)}{m.group(3)}-{m.group(2)}-{m.group(4)}" if len(m.groups()) >= 4 else f"{m.group(1)}{today}",
                    new_content,
                    flags=re.IGNORECASE
                )
            
            # Find and fix the main header date format from the screenshot
            # Direct replacement for the exact format from the screenshot
            main_pattern = r'(ALLURE REPORT )(\d)/(\d{2})/(\d{4})'
            new_content = re.sub(
                main_pattern,
                lambda m: f'{m.group(1)}{m.group(3)}-0{m.group(2)}-{m.group(4)}',
                new_content
            )
            
            # Try with full month number
            main_pattern2 = r'(ALLURE REPORT )(\d{2})/(\d{2})/(\d{4})'
            new_content = re.sub(
                main_pattern2,
                lambda m: f'{m.group(1)}{m.group(3)}-{m.group(2)}-{m.group(4)}',
                new_content
            )
            
            # Also try directly matching the example in the screenshot (3/29/2025)
            exact_pattern = r'(ALLURE REPORT )3/29/2025'
            if 'ALLURE REPORT 3/29/2025' in new_content:
                new_content = new_content.replace('ALLURE REPORT 3/29/2025', f'ALLURE REPORT 29-03-2025')
            
            # Inject a direct DOM manipulation script for SPA interfaces like the one in the screenshot
            # This will run on page load and fix dynamic content
            if html_file.endswith('index.html'):
                logger.info(f"Processing index.html, injecting dynamic content fix script")
                
                # Create a script to fix dates in the dynamic content - use raw string to avoid escape issues
                date_fix_script = fr"""
<script>
// Script to fix date formats in the Allure Report UI
document.addEventListener('DOMContentLoaded', function() {{
  // Run immediately and after content might have loaded
  fixAllureDates();
  setTimeout(fixAllureDates, 500);
  setTimeout(fixAllureDates, 1500);
  setTimeout(fixAllureDates, 3000);
  
  // Also set up a mutation observer to catch dynamic content
  const observer = new MutationObserver(function(mutations) {{
    fixAllureDates();
  }});
  
  // Start observing the document body for DOM changes
  observer.observe(document.body, {{
    childList: true,
    subtree: true
  }});
  
  function fixAllureDates() {{
    // Convert any MM/DD/YYYY to DD-MM-YYYY in the document
    const datePattern = /(ALLURE REPORT |Allure Report )(\d{{1,2}})\/(\d{{1,2}})\/(\d{{4}})/gi;
    
    // Process all text nodes in the document
    const textNodes = [];
    const walker = document.createTreeWalker(
      document.body,
      NodeFilter.SHOW_TEXT,
      null,
      false
    );
    
    let node;
    while (node = walker.nextNode()) {{
      if (node.nodeValue.match(datePattern)) {{
        node.nodeValue = node.nodeValue.replace(datePattern, function(match, prefix, month, day, year) {{
          return prefix + day + '-' + month + '-' + year;
        }});
      }}
    }}
    
    // Also check specific DOM elements that may contain the date
    const headerElement = document.querySelector('.header, [class*="header"], [class*="title"]');
    if (headerElement && headerElement.innerText) {{
      if (headerElement.innerText.match(datePattern)) {{
        headerElement.innerText = headerElement.innerText.replace(datePattern, function(match, prefix, month, day, year) {{
          return prefix + day + '-' + month + '-' + year;
        }});
      }}
    }}
    
    // Look for specific elements in the Allure UI that might contain the date
    document.querySelectorAll('.app__header, .header').forEach(function(el) {{
      if (el.innerText && el.innerText.match(datePattern)) {{
        el.innerText = el.innerText.replace(datePattern, function(match, prefix, month, day, year) {{
          return prefix + day + '-' + month + '-' + year;
        }});
      }}
    }});
    
    // Also add branch name to environment if not present and move it to the top
    const envSection = document.querySelector('.environment, [class*="environment"]');
    if (envSection) {{
      // First, find the table
      const table = envSection.querySelector('table');
      if (table) {{
        // Check if Branch row already exists, remove it if it does
        const branchRows = Array.from(table.querySelectorAll('tr')).filter(row => 
          row.cells && row.cells[0] && row.cells[0].textContent === 'Branch'
        );
        
        branchRows.forEach(row => row.remove());
        
        // Create new Branch row
        const branchValue = '{branch}';  // Use the actual branch name from Python
        const newRow = document.createElement('tr');
        newRow.innerHTML = '<td>Branch</td><td>' + branchValue + '</td>';
        
        // Insert at the beginning of the table
        if (table.rows.length > 0) {{
          table.insertBefore(newRow, table.rows[0]);
        }} else {{
          table.appendChild(newRow);
        }}
      }}
    }}
  }}
}});
</script>
"""
                # Add the script just before the closing body tag
                if '</body>' in new_content:
                    new_content = new_content.replace('</body>', date_fix_script + '</body>')
                    logger.info("Injected date format fixing script into index.html")
            
            if new_content != content:
                with open(html_file, 'w', encoding='utf-8') as f:
                    f.write(new_content)
        except Exception as e:
            logger.warning(f"Error fixing title in {html_file}: {e}")
    
    logger.info("Fixed date format in HTML title tags")


def fix_js_date_formats(report_dir: str) -> None:
    """Fix date formats in JavaScript files.
    
    Args:
        report_dir: Path to the Allure report directory.
    """
    today = get_current_date_formatted()
    
    js_files = glob.glob(os.path.join(report_dir, "**", "*.js"), recursive=True)
    fixed_count = 0
    
    for js_file in js_files:
        try:
            with open(js_file, 'r', encoding='utf-8') as f:
                content = f.read()
            
            modified = False
            
            # Replace date strings directly using regex pattern matching and direct string replacement
            date_patterns = [
                r'ALLURE\s+REPORT\s+\d{1,2}/\d{1,2}/\d{4}',
                r'Allure\s+Report\s+\d{1,2}/\d{1,2}/\d{4}',
                r'ALLURE\s+REPORT\s+\d{1,2}-\d{1,2}-\d{4}',
                r'Allure\s+Report\s+\d{1,2}-\d{1,2}-\d{4}'
            ]
            
            for pattern in date_patterns:
                regex = re.compile(pattern, re.IGNORECASE)
                matches = regex.findall(content)
                for match in matches:
                    content = content.replace(match, f'ALLURE REPORT {today}')
                    modified = True
            
            # Also look for title fields in JSON-like structures
            title_patterns = [
                r'"title"\s*:\s*"[^"]*\d{1,2}/\d{1,2}/\d{4}[^"]*"',
                r'"title"\s*:\s*"[^"]*\d{1,2}-\d{1,2}-\d{4}[^"]*"'
            ]
            
            for pattern in title_patterns:
                regex = re.compile(pattern, re.IGNORECASE)
                matches = regex.findall(content)
                for match in matches:
                    # Extract just the part between quotes after title:
                    content = content.replace(match, f'"title":"ALLURE REPORT {today}"')
                    modified = True
            
            # Special case for app.js - this is where the main UI component renders
            if os.path.basename(js_file) == 'app.js':
                # Look for any date format in arrays or objects
                date_format_patterns = [
                    r'(\d{1,2})/(\d{1,2})/(\d{4})',
                    r'(\d{1,2})-(\d{1,2})-(\d{4})'
                ]
                
                for pattern in date_format_patterns:
                    date_matches = re.finditer(pattern, content)
                    for match in date_matches:
                        # Check if this looks like a date in a UI component
                        start_pos = max(0, match.start() - 30)
                        end_pos = min(len(content), match.end() + 30)
                        context = content[start_pos:end_pos]
                        
                        # If it mentions allure, report, title, etc. it's likely our target
                        if re.search(r'allure|report|title', context, re.IGNORECASE):
                            month, day, year = match.groups()
                            replacement = f"{day}-{month}-{year}"
                            content = content.replace(match.group(0), replacement)
                            modified = True
                            logger.info(f"Fixed date format in app.js: {match.group(0)} -> {replacement}")
                
                # Also inject JS code to ensure proper date format rendering
                if 'DOMContentLoaded' in content:
                    # Add script to fix any dynamically rendered dates
                    date_fix_script = """
// Fix date formats to DD-MM-YYYY
document.addEventListener('DOMContentLoaded', function() {
  // Initial fix
  fixDateFormats();
  
  // Also try after dynamic content loads
  setTimeout(fixDateFormats, 1000);
  setTimeout(fixDateFormats, 2000);
  
  function fixDateFormats() {
    // Find all text nodes in the document
    const walker = document.createTreeWalker(
      document.body, 
      NodeFilter.SHOW_TEXT,
      null,
      false
    );
    
    const dateRegex = /(ALLURE\\s+REPORT\\s+)(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})/i;
    let node;
    
    while(node = walker.nextNode()) {
      const matches = node.nodeValue.match(dateRegex);
      if (matches) {
        const [fullMatch, prefix, month, day, year] = matches;
        node.nodeValue = node.nodeValue.replace(
          fullMatch,
          `${prefix}${day}-${month}-${year}`
        );
      }
    }
    
    // Also look for dates in the header
    const headerEls = document.querySelectorAll('header, .header, h1, h2, h3, [class*="header"]');
    headerEls.forEach(el => {
      if (el.innerText && dateRegex.test(el.innerText)) {
        el.innerText = el.innerText.replace(dateRegex, `$1$3-$2-$4`);
      }
    });
  }
});
"""
                    # Inject our script at the end, before the closing script tag
                    if '</script>' in content:
                        parts = content.rsplit('</script>', 1)
                        content = parts[0] + date_fix_script + '</script>' + parts[1]
                        modified = True
                        logger.info("Injected date format fixing script into app.js")
            
            if modified:
                with open(js_file, 'w', encoding='utf-8') as f:
                    f.write(content)
                fixed_count += 1
        except Exception as e:
            logger.warning(f"Error fixing JS date formats in {js_file}: {e}")
    
    logger.info(f"Fixed date formats in {fixed_count} JavaScript files")


def fix_json_timestamps(report_dir: str) -> None:
    """Fix timestamp format in JSON files.
    
    Args:
        report_dir: Path to the Allure report directory.
    """
    json_files = glob.glob(os.path.join(report_dir, "**", "*.json"), recursive=True)
    fixed_count = 0
    
    for json_file in json_files:
        try:
            with open(json_file, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Fix ISO timestamps to DD-MM-YYYY HH:MM:SS
            pattern = r'(\d{4}).(\d{2}).(\d{2})T(\d{2}):(\d{2}):(\d{2})'
            replacement = r'\3-\2-\1 \4:\5:\6'
            
            new_content = re.sub(pattern, replacement, content)
            
            if new_content != content:
                with open(json_file, 'w', encoding='utf-8') as f:
                    f.write(new_content)
                fixed_count += 1
        except Exception as e:
            logger.warning(f"Error fixing JSON timestamp in {json_file}: {e}")
    
    logger.info(f"Fixed timestamps in {fixed_count} JSON files")


def add_cache_control(report_dir: str) -> None:
    """Add cache control headers and meta tags.
    
    Args:
        report_dir: Path to the Allure report directory.
    """
    # Create _headers file for GitHub Pages
    headers_content = """/*
  Cache-Control: no-cache, no-store, must-revalidate
  Pragma: no-cache
  Expires: 0
"""
    with open(os.path.join(report_dir, "_headers"), "w") as f:
        f.write(headers_content)
    
    # Add cache control meta tags to HTML files
    html_files = glob.glob(os.path.join(report_dir, "**", "*.html"), recursive=True)
    fixed_count = 0
    
    for html_file in html_files:
        try:
            with open(html_file, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Check if cache meta tags already exist
            if '<meta http-equiv="Cache-Control"' not in content:
                cache_tags = '<head>\n<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">\n<meta http-equiv="Pragma" content="no-cache">\n<meta http-equiv="Expires" content="0">'
                new_content = content.replace('<head>', cache_tags)
                
                if new_content != content:
                    with open(html_file, 'w', encoding='utf-8') as f:
                        f.write(new_content)
                    fixed_count += 1
        except Exception as e:
            logger.warning(f"Error adding cache control to {html_file}: {e}")
    
    logger.info(f"Added cache control meta tags to {fixed_count} HTML files")


def remove_problematic_elements(report_dir: str) -> None:
    """Remove elements that might cause loading or display issues.
    
    Args:
        report_dir: Path to the Allure report directory.
    """
    html_files = glob.glob(os.path.join(report_dir, "**", "*.html"), recursive=True)
    fixed_count = 0
    
    for html_file in html_files:
        try:
            with open(html_file, 'r', encoding='utf-8') as f:
                content = f.read()
            
            modified = False
            
            # Remove meta refresh tags
            if '<meta http-equiv="refresh"' in content:
                new_content = re.sub(r'<meta\s+http-equiv=["\']refresh["\'][^>]*>', '', content)
                if new_content != content:
                    content = new_content
                    modified = True
            
            # Add CSS to ensure spinners don't stay visible
            if '</head>' in content and 'spinner-fix-styles' not in content:
                spinner_css = """<style id="spinner-fix-styles">
/* Ensure spinners don't stay visible indefinitely */
.spinner, .spinner_centered, [class*="spinner"] {
  animation-duration: 2s !important;
  animation-iteration-count: 1 !important;
}
</style>
</head>"""
                new_content = content.replace('</head>', spinner_css)
                if new_content != content:
                    content = new_content
                    modified = True
            
            if modified:
                with open(html_file, 'w', encoding='utf-8') as f:
                    f.write(content)
                fixed_count += 1
        except Exception as e:
            logger.warning(f"Error fixing problematic elements in {html_file}: {e}")
    
    logger.info(f"Removed problematic elements from {fixed_count} HTML files")


def create_dummy_report(report_dir: str) -> None:
    """Create a dummy report when no test results are available.
    
    Args:
        report_dir: Path to create the dummy report.
    """
    os.makedirs(report_dir, exist_ok=True)
    today = get_current_date_formatted()
    
    # Get the template file path
    template_path = os.path.join(os.path.dirname(__file__), "templates", "dummy_report.html")
    
    # Check if template exists
    if not os.path.exists(template_path):
        logger.warning(f"Template file not found at {template_path}. Using fallback template.")
        dummy_html = f"""<!DOCTYPE html>
<html>
<head>
    <title>ALLURE REPORT {today}</title>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <style>
        body {{ font-family: Arial, sans-serif; padding: 20px; line-height: 1.6; }}
        .container {{ max-width: 800px; margin: 0 auto; padding: 20px; border: 1px solid #ddd; border-radius: 5px; }}
        h1 {{ color: #333; }}
        .footer {{ margin-top: 30px; color: #666; font-size: 0.9em; }}
    </style>
</head>
<body>
    <div class="container">
        <h1>ALLURE REPORT {today}</h1>
        <p>No test results available for this run.</p>
        <p>Please check the workflow logs for more information.</p>
        <div class="footer">Generated on: {datetime.now().strftime("%d-%m-%Y %H:%M:%S")}</div>
    </div>
</body>
</html>"""
    else:
        # Read the template file
        with open(template_path, 'r', encoding='utf-8') as f:
            template_content = f.read()
        
        # Replace placeholders with values
        dummy_html = template_content.replace('{today}', today).replace('{timestamp}', datetime.now().strftime("%d-%m-%Y %H:%M:%S"))
    
    # Write the HTML to index.html
    with open(os.path.join(report_dir, "index.html"), "w", encoding='utf-8') as f:
        f.write(dummy_html)
    
    # Create cache control files
    add_cache_control(report_dir)
    create_nojekyll_file(report_dir)
    
    logger.info("Created dummy report")


def main() -> int:
    """Entry point for the script."""
    # Support environment variables for CI/CD pipeline integration
    report_dir = os.environ.get("ALLURE_REPORT_DIR", "reports/allure-report")
    create_dummy = os.environ.get("ALLURE_CREATE_DUMMY", "false").lower() == "true"
    custom_branch = os.environ.get("ALLURE_BRANCH", None)
    
    # Command line args override environment variables
    i = 1
    while i < len(sys.argv):
        arg = sys.argv[i]
        if arg.startswith("--"):
            if arg == "--dummy":
                create_dummy = True
            elif arg == "--branch" and i + 1 < len(sys.argv):
                custom_branch = sys.argv[i + 1]
                i += 1
            elif arg == "--dry-run":
                # Add dry-run mode for testing in pipelines
                logger.info("Running in dry-run mode, no changes will be applied")
                DRY_RUN = True
        else:
            report_dir = arg
        i += 1
    
    logger.info(f"Processing Allure report in {report_dir}...")
    
    # Create dummy report if requested
    if create_dummy:
        create_dummy_report(report_dir)
        logger.info("Dummy report created successfully!")
        return 0
    
    # Ensure the directory exists
    if not os.path.isdir(report_dir):
        logger.error(f"Error: Directory {report_dir} does not exist!")
        return 1
    
    # Check if directory is empty
    if not os.listdir(report_dir):
        logger.warning(f"Warning: Directory {report_dir} is empty. Creating dummy report.")
        create_dummy_report(report_dir)
        return 0
    
    # Apply customizations (in appropriate order to minimize file reads/writes)
    try:
        # 1. Fix the date formats in various files
        fix_html_title_tags(report_dir)
        fix_js_date_formats(report_dir)
        fix_json_timestamps(report_dir)
        
        # 2. Remove problematic elements causing loading issues
        remove_problematic_elements(report_dir)
        
        # 3. Add cache control
        add_cache_control(report_dir)
        
        # 4. Add branch info (with custom branch if provided)
        add_branch_info(report_dir, custom_branch)
        
        # 5. Create .nojekyll file
        create_nojekyll_file(report_dir)
        
        logger.info("Allure report customization completed successfully!")
        return 0
    except Exception as e:
        logger.error(f"Error customizing Allure report: {e}")
        return 1


if __name__ == "__main__":
    sys.exit(main()) 